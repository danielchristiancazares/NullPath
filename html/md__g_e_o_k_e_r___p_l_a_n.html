<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: GEOKER bit‑exact parity roadmap</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__g_e_o_k_e_r___p_l_a_n.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GEOKER bit‑exact parity roadmap </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>This plan drives the CUDA GeoKerr (GPU) implementation to bit‑exact parity with the reference (CPU) along a single, reproducible configuration. It breaks the work into strict determinism controls, math library alignment, algorithmic alignment, and verification hardening.</p>
<p>Success criteria:</p><ul>
<li>For the target platform (specified below), every validated field sample matches bit‑for‑bit: ULP distance = 0 across the entire grid and all cases.</li>
<li>Validator passes with quantization disabled (quant_lsb = 0) and ULP check enabled, with atol = rtol = 0 in “bit‑exact mode”.</li>
</ul>
<p>Scope and assumptions:</p><ul>
<li>Target a single deterministic hardware/software stack first; broaden later.</li>
<li>We accept any performance loss during the bring‑up; we can re‑optimize under constraints once parity is achieved.</li>
</ul>
<p>Target baseline (locked):</p><ul>
<li>GPU arch: one specific SM (e.g., sm_86 on the current machine; adjust as needed).</li>
<li>CUDA: the version installed in this repo’s environment (record exact version).</li>
<li>Compiler(s): GCC/Clang exact version; NVCC exact version.</li>
<li>OS/driver: current WSL/driver versions recorded.</li>
</ul>
<p>Deliverables:</p><ul>
<li>Deterministic build configurations (Makefile updates) for CPU and GPU.</li>
<li>Shared deterministic math layer used by both CPU and GPU paths.</li>
<li>Extended validator configuration: bit‑exact mode and detailed mismatch tracing.</li>
<li>Documentation and CI check that enforces bit‑exact on the target stack.</li>
</ul>
<p>Bit‑exact profile defaults (recommended for initial bring‑up):</p><ul>
<li>Grid size S: start small (e.g., 256–512) to speed iteration.</li>
<li>Grid spacing delta: 1e-4 (tunable). 1e-3 is acceptable but coarser; smaller deltas help isolate early‑step drift.</li>
<li>Quantization: 0 (disabled).</li>
<li>Tolerances: atol=0, rtol=0, max_ulps=0.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Phase 0 — Baseline capture and reproducibility</h1>
<p>1) Inventory and freeze environment</p><ul>
<li>Record: GPU model + SM, NVIDIA driver, CUDA toolkit, NVCC, GCC/Clang.</li>
<li>Lock compiler flags via Makefile to a new "deterministic" config.</li>
</ul>
<p>2) Determinism audit (current code)</p><ul>
<li>Ensure no parallel reductions or data‑dependent iteration counts that differ between CPU/GPU.</li>
<li>Ensure branch thresholds/epsilons identical and centralized.</li>
<li>Ensure no non‑deterministic atomics or unordered writes are used in validated paths.</li>
</ul>
<p>3) Validation harness hardening</p><ul>
<li>Re‑enable ULP check in <span class="tt">gkval_core.c</span> and add a "bit‑exact" profile:<ul>
<li>tolerances: atol = 0, rtol = 0, max_ulps = 0</li>
<li>quantization: quant_lsb = 0.</li>
</ul>
</li>
<li>Add option to dump first mismatch with: index, field, a_bits, b_bits, ulp, and the expression lineage if available.</li>
</ul>
<p>Exit criteria: repeatable runs (same hashes) on the target machine with today’s code/flags, even if not yet bit‑exact.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Phase 1 — Strict FP semantics alignment (toolchain &amp; flags)</h1>
<p>Goal: eliminate compiler/runtime FP variance between CPU and GPU.</p>
<p>A) Host compiler flags (CPU reference build)</p><ul>
<li>Disable fast‑math and contraction; standard rounding and precision:<ul>
<li><span class="tt">-O2 -fno-fast-math -fno-associative-math -fno-unsafe-math-optimizations -ffp-contract=off</span></li>
<li><span class="tt">-fexcess-precision=standard -frounding-math</span></li>
<li>On x86‑64, force SSE (avoid x87 extended precision): <span class="tt">-mfpmath=sse -msse2</span></li>
</ul>
</li>
<li>Do not use <span class="tt">-ffloat-store</span> unless a last‑resort (hurts perf and not usually needed with SSE2).</li>
</ul>
<p>B) Device compiler flags (CUDA build)</p><ul>
<li>Enforce IEEE‑like semantics and disable fused transformations unless used explicitly:<ul>
<li><span class="tt">--fmad=false</span> (or use explicit <span class="tt">fma</span> on both sides; see Phase 2)</li>
<li><span class="tt">--prec-div=true --prec-sqrt=true</span></li>
<li><span class="tt">-ftz=false</span> (preserve subnormals)</li>
</ul>
</li>
<li>Do not use <span class="tt">--use_fast_math</span>.</li>
<li>Target a single SM: <span class="tt">-arch=sm_XX -code=sm_XX</span> where XX is the chosen baseline.</li>
</ul>
<p>C) Runtime FP state</p><ul>
<li>CPU: ensure FE_TONEAREST and that FTZ/DAZ are disabled (already implemented in <span class="tt">gkval_validate_fp_env</span>).</li>
<li>GPU: rely on compile options above (no fast‑math, no FTZ), and avoid intrinsics with unspecified rounding.</li>
</ul>
<p>Exit criteria: micro‑kernels using only +, −, ×, ÷, sqrt produce identical bit patterns CPU vs GPU for controlled inputs.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Phase 2 — Deterministic math layer (shared CPU/GPU)</h1>
<p>Goal: remove libm/libdevice drift; unify the exact operations and rounding points used in the algorithm.</p>
<p>1) Create <span class="tt">include/geokerr_math.h</span> + <span class="tt">src/geokerr_math.cu</span></p><ul>
<li>Provide a minimal set of primitives as inline <span class="tt">__host__ __device__</span> functions for double:<ul>
<li>add/sub/mul with explicit rounding on device: <span class="tt">__dadd_rn</span>, <span class="tt">__dsub_rn</span>, <span class="tt">__dmul_rn</span> (CUDA intrinsics).</li>
<li><span class="tt">fma_rn(a,b,c)</span>: on CPU call <span class="tt">fma(a,b,c)</span>, on GPU call <span class="tt">__fma_rn(a,b,c)</span>.</li>
<li><span class="tt">div_rn(a,b)</span>: device relies on precise division; host uses <span class="tt">/</span>.</li>
<li><span class="tt">sqrt_rn(x)</span>: device uses <span class="tt">sqrt(x)</span> with <span class="tt">--prec-sqrt=true</span>; host uses <span class="tt">sqrt</span>.</li>
</ul>
</li>
<li>Replace compound expressions in hot paths with these primitives to lock operation order and rounding.</li>
</ul>
<p>2) Transcendentals inventory</p><ul>
<li>Catalog all uses of <span class="tt">pow</span>, <span class="tt">exp</span>, <span class="tt">log</span>, <span class="tt">sin</span>, <span class="tt">cos</span>, <span class="tt">atan2</span>, etc.</li>
<li>Prefer algorithmic rewrites to avoid transcendentals where possible (e.g., fixed powers via multiplies; <span class="tt">exp(log(x)*n)</span> replaced by repeated mul for small integer n).</li>
<li>If any transcendental remains in the validated path, consider a shared, deterministic implementation:<ul>
<li>Option A (best): integrate a correctly‑rounded library usable on CPU, and port a numerically identical path to CUDA (limited surface, e.g., <span class="tt">log</span>, <span class="tt">exp</span>).</li>
<li>Option B (pragmatic): implement the specific approximations we need in header‑only form and use identically on CPU/GPU.</li>
</ul>
</li>
</ul>
<p>3) Constants hygiene</p><ul>
<li>Express critical constants as hexadecimal floating literals to fix exact binary values (e.g., <span class="tt">0x1.921fb54442d18p+1</span> for π).</li>
<li>Centralize all epsilons/tolerances in one header; avoid duplicated literals across files.</li>
</ul>
<p>4) Operation ordering</p><ul>
<li>Parenthesize expressions to pin evaluation order.</li>
<li>Replace fragile algebraic rewrites with explicit sequencing via the math wrappers.</li>
</ul>
<p>Exit criteria: unit tests for the math layer show CPU/GPU identity at the bit level across a representative input corpus.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Phase 3 — Algorithmic alignment and control flow stability</h1>
<p>Goal: ensure both implementations traverse identical branches and iteration counts.</p>
<p>1) Carlson elliptic integrals path</p><ul>
<li>Ensure both CPU and GPU call the same source for Carlson RF/RC/RD/RJ with identical iteration limits and termination criteria.</li>
<li>Use the shared math primitives for all steps to lock rounding and sequence.</li>
</ul>
<p>2) Iterative solvers / steppers</p><ul>
<li>Fix maximum iteration counts and stopping conditions identically.</li>
<li>Avoid early‑exit conditions that depend on sub‑ULP differences; compare against centralized epsilons.</li>
</ul>
<p>3) Summations and reductions</p><ul>
<li>Replace naive accumulation with Kahan or Neumaier compensated summation on both sides if accumulation length &gt; O(10^3).</li>
<li>Keep summation order fixed (no parallel tree reductions in validated code paths).</li>
</ul>
<p>Exit criteria: trace logs of branch decisions (optional debug mode) show identical sequences CPU vs GPU for representative cases.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Phase 4 — Validator: bit‑exact mode and diagnostics</h1>
<p>1) Re‑enable and enforce ULP checks</p><ul>
<li>Set <span class="tt">max_ulps = 0</span> for bit‑exact runs; set <span class="tt">atol = rtol = 0</span> and <span class="tt">quant_lsb = 0</span>.</li>
<li>Add a CLI preset in <span class="tt">gkval_cli</span> (e.g., <span class="tt">--profile bitexact</span>) that configures the manifest accordingly.</li>
</ul>
<p>2) Mismatch forensics</p><ul>
<li>On first mismatch, dump:<ul>
<li>sample index, field, <span class="tt">a_bits</span>, <span class="tt">b_bits</span>, <span class="tt">a_hex</span>, <span class="tt">b_hex</span>, ULP distance.</li>
<li>optional: a compact provenance record (which high‑level function produced the value) via tagged checkpoints in code.</li>
</ul>
</li>
</ul>
<p>3) Reproducibility gate</p><ul>
<li>Add a CI job on the target runner that builds CPU and GPU in deterministic mode and runs the validator. Failing parity blocks merges to main.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Phase 5 — Performance recapture (post‑parity)</h1>
<ul>
<li>Gradually re‑enable optimizations that don’t change results (prove with validator):<ul>
<li>Allow explicit <span class="tt">fma_rn</span> where mathematically equivalent; keep same on CPU using <span class="tt">fma</span>.</li>
<li>Evaluate <span class="tt">-Xptxas</span> optimizations that preserve rounding (validate each change).</li>
<li>Consider mixed precision only for non‑validated paths.</li>
</ul>
</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Work breakdown and timeline (first pass)</h1>
<p>Week 1</p><ul>
<li>Implement deterministic build targets (Makefile updates for flags above).</li>
<li>Re‑enable ULP check and add bit‑exact profile in validator.</li>
<li>Add math layer scaffolding and micro‑tests (CPU vs GPU) for +, −, ×, ÷, fma, sqrt.</li>
</ul>
<p>Week 2</p><ul>
<li>Port Carlson integrals to use math layer; replace literals with hex‑floats.</li>
<li>Instrument branch traces (debug) and align iteration thresholds.</li>
<li>Achieve bit‑exact on a single end‑to‑end case with reduced grid.</li>
</ul>
<p>Week 3</p><ul>
<li>Scale to full test suite; address any residual mismatches with targeted diffs.</li>
<li>Add CI gate and documentation. Start performance recapture experiments.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Makefile notes (to implement)</h1>
<p>CPU (reference):</p><ul>
<li>CFLAGS (add): <span class="tt">-O2 -fno-fast-math -fno-associative-math -fno-unsafe-math-optimizations -ffp-contract=off -fexcess-precision=standard -frounding-math -mfpmath=sse -msse2</span></li>
</ul>
<p>CUDA:</p><ul>
<li>NVCC flags (device): <span class="tt">--fmad=false --prec-div=true --prec-sqrt=true -ftz=false -arch=sm_XX -code=sm_XX</span></li>
<li>NVCC host pass‐through: add CPU flags via <span class="tt">-Xcompiler</span> as appropriate.</li>
</ul>
<p>Validator bit‑exact preset:</p><ul>
<li><span class="tt">atol=0</span>, <span class="tt">rtol=0</span>, <span class="tt">max_ulps=0</span>, <span class="tt">quant_lsb=0</span>, grid unchanged.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Risks and mitigations</h1>
<ul>
<li>Libm vs libdevice differences: mitigate by using our shared math layer and avoiding generic libm/libdevice in validated paths.</li>
<li>Subnormal/rounding behavior: enforce via flags (<span class="tt">-ftz=false</span>, SSE DAZ/FTZ off) and wrappers.</li>
<li>Compiler re‑association: disabled via flags and by explicit parentheses and <span class="tt">ffp-contract=off</span>.</li>
<li>Hardware variance: start with one SM; later add per‑SM golden baselines and/or per‑SM builds.</li>
<li>Effort creep for transcendentals: minimize by avoiding them or isolating to a small, shared implementation.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Definition of Done (bit‑exact)</h1>
<ul>
<li>Validator run in bit‑exact mode passes across all selected cases and fields with ULP=0 and zero tolerances.</li>
<li>Repeatable across reruns on the locked target machine and SM.</li>
<li>CI job enforces the above on every change. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
